{"version":3,"sources":["smart-table.min.js"],"names":["ng","undefined","module","run","$templateCache","put","constant","pagination","template","itemsByPage","displayedPages","search","delay","inputEvent","select","mode","selectedClass","sort","ascentClass","descentClass","descendingFirst","skipNatural","pipe","tree","nodesInitiallyOpen","controller","$scope","$parse","$filter","$attrs","stConfig","copyRefs","src","copy","concat","isTreeTable","treeifyData","updateSafeCopy","safeCopy","safeGetter","pipeAfterSafeCopy","ctrl","deepDelete","object","path","indexOf","partials","split","key","pop","parentPath","join","parentObject","Object","keys","length","data","findTreeAncestors","datum","idx","ancestors","i","treeLevel","push","$$treeId","ancestorSet","$$treeDescendents","$$treeAncestors","getInitiallyOpen","angular","isObject","initiallyOpen","hasOwnProperty","forEach","d","toString","Math","floor","random","$$treeIsExpanded","$$treeShown","k","nodeExpanded","checkDescendentVisibility","descIdx","shown","ancId","parseInitiallyOpenAttr","treeOpenGetter","stTreeInitOpen","treeOpen","returnObj","prop","Boolean","JSON","parse","toLowerCase","setSelectedRowWatch","selectedRowWatch","$watch","selectedRowGetter","newValue","oldValue","_this","filtered","lastSelected","this","propertyName","stTable","displayGetter","displaySetter","assign","orderBy","filter","tableState","start","totalItemCount","stSelectedRow","stSafeSrc","safeSrc","sortBy","predicate","reverse","isFunction","functionName","name","input","predicateObject","isString","trim","output","number","numberOfPages","ceil","slice","parseInt","row","rows","index","isSelected","getFilteredCollection","setFilterFunction","filterName","setSortFunction","sortFunctionName","preventPipeOnWatch","toggleRow","treeId","treeIdx","$apply","checkExpanded","directive","restrict","link","scope","element","attr","stSetFilter","stSetSort","$timeout","require","tableCtrl","promise","throttle","stDelay","event","stInputEvent","$observe","value","predicateExpression","stSearch","bind","evt","originalEvent","cancel","target","onSelect","stSelectMode","stOnSelect","addClass","removeClass","func","getter","isArray","stSort","onSort","sortDefault","classAscent","stClassAscent","classDescent","stClassDescent","stateClasses","stSkipNatural","stDescendingFirst","stOnSort","$eval","stSortDefault","stItemsByPage","stDisplayedPages","stPageChange","templateUrl","attrs","stTemplate","redraw","end","paginationState","prevPage","currentPage","max","abs","pages","numPages","newPage","selectPage","page","config","stPipe","pre","pipePromise","post","priority","compile","tElement","tAttrs","repeat","ngRepeat","rptVar","caretEl","find","toggleExists","toggleIsExpanded","toggleLevel","stTreeId","stTreeLevel","stTreeIndex","$event","stopPropagation","spacerClass"],"mappings":"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","file":"smart-table.min.js","sourcesContent":["(function (ng, undefined){\n    'use strict';\n\nng.module('smart-table', []).run(['$templateCache', function ($templateCache) {\n    $templateCache.put('template/smart-table/pagination.html',\n        '<nav ng-if=\"numPages && pages.length >= 2\"><ul class=\"pagination\">' +\n        '<li ng-repeat=\"page in pages\" ng-class=\"{active: page==currentPage}\"><a href=\"javascript: void(0);\" ng-click=\"selectPage(page)\">{{page}}</a></li>' +\n        '</ul></nav>');\n        \n    $templateCache.put('sttable/template/st-tree-toggle.html',\n        '<span ng-class=\"spacerClass\"></span><i ng-if=\"toggleExists\" ng-class=\"toggleIsExpanded ? \\'fa fa-caret-down\\' : \\'fa fa-caret-right\\'\"></i>\\n' +\n        '');\n}]);\n\nng.module('smart-table')\n  .constant('stConfig', {\n    pagination: {\n      template: 'template/smart-table/pagination.html',\n      itemsByPage: 10,\n      displayedPages: 5\n    },\n    search: {\n      delay: 400, // ms\n      inputEvent: 'input'\n    },\n    select: {\n      mode: 'single',\n      selectedClass: 'st-selected'\n    },\n    sort: {\n      ascentClass: 'st-sort-ascent',\n      descentClass: 'st-sort-descent',\n      descendingFirst: false,\n      skipNatural: false,\n      delay:300\n    },\n    pipe: {\n      delay: 100 //ms\n    },\n    tree: {\n      nodesInitiallyOpen: true\n    }\n  });\n\nng.module('smart-table')\n  .controller('stTableController', ['$scope', '$parse', '$filter', '$attrs', 'stConfig', function StTableController ($scope, $parse, $filter, $attrs, stConfig) {\n    var _this = this;\n    var propertyName = $attrs.stTable;\n    var displayGetter = $parse(propertyName);\n    var displaySetter = displayGetter.assign;\n    var safeGetter;\n    var orderBy = $filter('orderBy');\n    var filter = $filter('filter');\n    var safeCopy = copyRefs(displayGetter($scope));\n    var tableState = {\n      sort: {},\n      search: {},\n      pagination: {\n        start: 0,\n        totalItemCount: 0\n      }\n    };\n    var filtered;\n    var pipeAfterSafeCopy = true;\n    var ctrl = this;\n    var lastSelected;\n    var isTreeTable = 'stTreeTable' in $attrs;\n    var nodeExpanded = {};\n    var initiallyOpen = 'stTreeInitOpen' in $attrs ? parseInitiallyOpenAttr() : stConfig.tree.nodesInitiallyOpen;\n    var selectedRowGetter;\n    var selectedRowWatch;\n    if ($attrs.stSelectedRow) selectedRowGetter = $parse($attrs.stSelectedRow);\n    \n    \n    function copyRefs (src) {\n      var copy = src ? [].concat(src) : [];\n      if (isTreeTable) {\n        treeifyData(copy);\n      }\n      return copy;\n    }\n\n    function updateSafeCopy () {\n      safeCopy = copyRefs(safeGetter($scope));\n      if (pipeAfterSafeCopy === true) {\n        ctrl.pipe();\n      }\n    }\n\n    function deepDelete (object, path) {\n      if (path.indexOf('.') != -1) {\n        var partials = path.split('.');\n        var key = partials.pop();\n        var parentPath = partials.join('.');\n        var parentObject = $parse(parentPath)(object);\n        delete parentObject[key];\n        if (Object.keys(parentObject).length === 0) {\n          deepDelete(object, parentPath);\n        }\n      } else {\n        delete object[path];\n      }\n    }\n    \n    function treeifyData(data) {\n      data.forEach(function(d, i) {\n        if (!d.$$treeId) d.$$treeId = d.treeLevel.toString() + i + Math.floor(Math.random()*10000);\n      });\n      var ancestorSet = {};\n      data.forEach(function(d, i) {\n        if (d.treeLevel > 0) {\n          d.$$treeDescendents = [];\n          if (!d.hasOwnProperty('$$treeIsExpanded')) d.$$treeIsExpanded = getInitiallyOpen(d.treeLevel);\n        }\n        d.$$treeAncestors = findTreeAncestors(d, i);\n        d.$$treeShown = d.treeLevel > 0;\n      });\n      \n      Object.keys(ancestorSet).forEach(function(k) {\n        if (!nodeExpanded.hasOwnProperty(k)) {\n          var d;\n          for (var i = 0 ; i < data.length; i++) {\n            if (data[i].$$treeId === k) {\n              d = data[i];\n              break;\n            }\n          };\n          nodeExpanded[k] = d.$$treeIsExpanded;\n        }\n      });\n      \n      data.forEach(function(d, i) {\n        if (d.treeLevel > 0) checkDescendentVisibility(data, i);\n      });\n      \n      function findTreeAncestors(datum, idx) {\n        var ancestors = [];\n        for (var i = idx; i >= 0; i--) {\n          if (data[i].treeLevel > datum.treeLevel) {\n            ancestors.push(data[i].$$treeId);\n            ancestorSet[data[i].$$treeId] = true;\n            data[i].$$treeDescendents.push(idx);\n            return ancestors.concat(data[i].$$treeAncestors);\n          }\n        }\n        return ancestors;\n      }\n      \n      function getInitiallyOpen(treeLevel) {\n        if (angular.isObject(initiallyOpen)) {\n          return initiallyOpen.hasOwnProperty(treeLevel) ? initiallyOpen[treeLevel] : stConfig.tree.nodesInitiallyOpen;\n        } else {\n          return initiallyOpen;\n        }\n      }\n    }\n    \n    function checkDescendentVisibility(data, idx) {\n      data[idx].$$treeDescendents.forEach(function(descIdx) {\n        var shown = true;\n        data[descIdx].$$treeAncestors.forEach(function(ancId) {\n          shown = shown && nodeExpanded[ancId];\n        });\n        data[descIdx].$$treeShown = shown;\n        if (data[descIdx].$$treeDescendents) {\n          checkDescendentVisibility(data, descIdx);\n        }\n      });\n    }\n    \n    function parseInitiallyOpenAttr() {\n      var treeOpenGetter = $parse($attrs.stTreeInitOpen);\n      var treeOpen = treeOpenGetter($scope);\n      if (angular.isObject(treeOpen)) {\n        var returnObj = {};\n        for (var prop in treeOpen) {\n          returnObj[prop] = Boolean(JSON.parse(treeOpen[prop]));\n        }\n        return returnObj;\n      } else {\n        return Boolean(JSON.parse(treeOpen.toLowerCase()));\n      }\n    }\n    \n    function setSelectedRowWatch() {\n      selectedRowWatch = $scope.$watch(function () {\n        return selectedRowGetter($scope);\n      }, function(newValue, oldValue) {\n        if (newValue && newValue !== oldValue) _this.select(newValue, 'single')\n      });\n    };\n\n    if ($attrs.stSafeSrc) {\n      safeGetter = $parse($attrs.stSafeSrc);\n      $scope.$watch(function () {\n        var safeSrc = safeGetter($scope);\n        return safeSrc && safeSrc.length ? safeSrc[0] : undefined;\n      }, function (newValue, oldValue) {\n        if (newValue !== oldValue) {\n          updateSafeCopy();\n        }\n      });\n      $scope.$watch(function () {\n        var safeSrc = safeGetter($scope);\n        return safeSrc ? safeSrc.length : 0;\n      }, function (newValue, oldValue) {\n        if (newValue !== safeCopy.length) {\n          updateSafeCopy();\n        }\n      });\n      $scope.$watch(function () {\n        return safeGetter($scope);\n      }, function (newValue, oldValue) {\n        if (newValue !== oldValue) {\n          tableState.pagination.start = 0;\n          updateSafeCopy();\n        }\n      });\n    }\n\n    /**\n     * sort the rows\n     * @param {Function | String} predicate - function or string which will be used as predicate for the sorting\n     * @param [reverse] - if you want to reverse the order\n     */\n    this.sortBy = function sortBy (predicate, reverse) {\n      tableState.sort.predicate = predicate;\n      tableState.sort.reverse = reverse === true;\n\n      if (ng.isFunction(predicate)) {\n        tableState.sort.functionName = predicate.name;\n      } else {\n        delete tableState.sort.functionName;\n      }\n\n      tableState.pagination.start = 0;\n      return this.pipe();\n    };\n\n    /**\n     * search matching rows\n     * @param {String} input - the input string\n     * @param {String} [predicate] - the property name against you want to check the match, otherwise it will search on all properties\n     */\n    this.search = function search (input, predicate) {\n      var predicateObject = tableState.search.predicateObject || {};\n      var prop = predicate ? predicate : '$';\n\n      input = ng.isString(input) ? input.trim() : input;\n      $parse(prop).assign(predicateObject, input);\n      // to avoid to filter out null value\n      if (!input) {\n        deepDelete(predicateObject, prop);\n      }\n      tableState.search.predicateObject = predicateObject;\n      tableState.pagination.start = 0;\n      return this.pipe();\n    };\n\n    /**\n     * this will chain the operations of sorting and filtering based on the current table state (sort options, filtering, ect)\n     */\n    this.pipe = function pipe () {\n      var pagination = tableState.pagination;\n      var output;\n      filtered = tableState.search.predicateObject ? filter(safeCopy, tableState.search.predicateObject) : safeCopy;\n      if (tableState.sort.predicate) {\n        filtered = orderBy(filtered, tableState.sort.predicate, tableState.sort.reverse);\n      }\n      pagination.totalItemCount = filtered.length;\n      if (pagination.number !== undefined) {\n        pagination.numberOfPages = filtered.length > 0 ? Math.ceil(filtered.length / pagination.number) : 1;\n        pagination.start = pagination.start >= filtered.length ? (pagination.numberOfPages - 1) * pagination.number : pagination.start;\n        output = filtered.slice(pagination.start, pagination.start + parseInt(pagination.number));\n      }\n      displaySetter($scope, output || filtered);\n    };\n\n    /**\n     * select a dataRow (it will add the attribute isSelected to the row object)\n     * @param {Object} row - the row to select\n     * @param {String} [mode] - \"single\" or \"multiple\" (multiple by default)\n     */\n    this.select = function select (row, mode) {\n      var rows = copyRefs(displayGetter($scope));\n      var index = rows.indexOf(row);\n      if (index !== -1) {\n        if (mode === 'single') {\n          row.isSelected = row.isSelected !== true;\n          if (lastSelected) {\n            lastSelected.isSelected = false;\n          }\n          if ($attrs.stSelectedRow) {\n            selectedRowWatch()\n            selectedRowGetter.assign($scope, row);\n            setSelectedRowWatch();\n          }\n          lastSelected = row.isSelected === true ? row : undefined;\n        } else {\n          rows[index].isSelected = !rows[index].isSelected;\n        }\n      } else { // if a bad row selection is passed in, deselect the current row\n        if ($attrs.stSelectedRow) {\n          lastSelected.isSelected = false;\n          lastSelected = undefined;\n        }\n      }\n    };\n\n    /**\n     * take a slice of the current sorted/filtered collection (pagination)\n     *\n     * @param {Number} start - start index of the slice\n     * @param {Number} number - the number of item in the slice\n     */\n    this.slice = function splice (start, number) {\n      tableState.pagination.start = start;\n      tableState.pagination.number = number;\n      return this.pipe();\n    };\n\n    /**\n     * return the current state of the table\n     * @returns {{sort: {}, search: {}, pagination: {start: number}}}\n     */\n    this.tableState = function getTableState () {\n      return tableState;\n    };\n\n    this.getFilteredCollection = function getFilteredCollection () {\n      return filtered || safeCopy;\n    };\n\n    /**\n     * Use a different filter function than the angular FilterFilter\n     * @param filterName the name under which the custom filter is registered\n     */\n    this.setFilterFunction = function setFilterFunction (filterName) {\n      filter = $filter(filterName);\n    };\n\n    /**\n     * Use a different function than the angular orderBy\n     * @param sortFunctionName the name under which the custom order function is registered\n     */\n    this.setSortFunction = function setSortFunction (sortFunctionName) {\n      orderBy = $filter(sortFunctionName);\n    };\n\n    /**\n     * Usually when the safe copy is updated the pipe function is called.\n     * Calling this method will prevent it, which is something required when using a custom pipe function\n     */\n    this.preventPipeOnWatch = function preventPipe () {\n      pipeAfterSafeCopy = false;\n    };\n    \n    /**\n     * Open or close a tree level.\n     * @param treeId the unique id of the tree table row being toggled\n     * @param treeIdx the index of the row in the table\n     */\n    this.toggleRow = function toggleRow (treeId, treeIdx) {\n      nodeExpanded[treeId] = !nodeExpanded[treeId];\n      safeCopy[treeIdx].$$treeIsExpanded = nodeExpanded[treeId];\n      $scope.$apply(function() {\n        checkDescendentVisibility(safeCopy, treeIdx);\n      });\n    };\n    \n    /**\n     * Check if a tree level is open or closed\n     * @param treeId the unique id of the tree table row being checked\n     */\n    this.checkExpanded = function checkExpanded (treeId) {\n      return nodeExpanded[treeId];\n    };\n\n    if ($attrs.stSelectedRow) {\n      setSelectedRowWatch();\n    }\n    \n  }])\n  .directive('stTable', function () {\n    return {\n      restrict: 'A',\n      controller: 'stTableController',\n      link: function (scope, element, attr, ctrl) {\n\n        if (attr.stSetFilter) {\n          ctrl.setFilterFunction(attr.stSetFilter);\n        }\n\n        if (attr.stSetSort) {\n          ctrl.setSortFunction(attr.stSetSort);\n        }\n      }\n    };\n  });\n\nng.module('smart-table')\n  .directive('stSearch', ['stConfig', '$timeout','$parse', function (stConfig, $timeout, $parse) {\n    return {\n      require: '^stTable',\n      link: function (scope, element, attr, ctrl) {\n        var tableCtrl = ctrl;\n        var promise = null;\n        var throttle = attr.stDelay || stConfig.search.delay;\n        var event = attr.stInputEvent || stConfig.search.inputEvent;\n\n        attr.$observe('stSearch', function (newValue, oldValue) {\n          var input = element[0].value;\n          if (newValue !== oldValue && input) {\n            ctrl.tableState().search = {};\n            tableCtrl.search(input, newValue);\n          }\n        });\n\n        //table state -> view\n        scope.$watch(function () {\n          return ctrl.tableState().search;\n        }, function (newValue, oldValue) {\n          var predicateExpression = attr.stSearch || '$';\n          if (newValue.predicateObject && $parse(predicateExpression)(newValue.predicateObject) !== element[0].value) {\n            element[0].value = $parse(predicateExpression)(newValue.predicateObject) || '';\n          }\n        }, true);\n\n        // view -> table state\n        element.bind(event, function (evt) {\n          evt = evt.originalEvent || evt;\n          if (promise !== null) {\n            $timeout.cancel(promise);\n          }\n\n          promise = $timeout(function () {\n            tableCtrl.search(evt.target.value, attr.stSearch || '');\n            promise = null;\n          }, throttle);\n        });\n      }\n    };\n  }]);\n\nng.module('smart-table')\n  .directive('stSelectRow', ['stConfig', function (stConfig) {\n    return {\n      restrict: 'A',\n      require: '^stTable',\n      scope: {\n        row: '=stSelectRow',\n        onSelect: '=?stOnSelect'\n      },\n      link: function (scope, element, attr, ctrl) {\n        var mode = attr.stSelectMode || stConfig.select.mode;\n        element.bind('click', function () {\n          scope.$apply(function () {\n            ctrl.select(scope.row, mode);\n            if (attr.stOnSelect) scope.onSelect(scope.row);\n          });\n        });\n\n        scope.$watch('row.isSelected', function (newValue) {\n          if (newValue === true) {\n            element.addClass(stConfig.select.selectedClass);\n          } else {\n            element.removeClass(stConfig.select.selectedClass);\n          }\n        });\n      }\n    };\n  }]);\n\nng.module('smart-table')\n  .directive('stSort', ['stConfig', '$parse', '$timeout', function (stConfig, $parse, $timeout) {\n    return {\n      restrict: 'A',\n      require: '^stTable',\n      link: function (scope, element, attr, ctrl) {\n\n        var predicate = attr.stSort;\n        var getter = $parse(predicate);\n        var index = 0;\n        var classAscent = attr.stClassAscent || stConfig.sort.ascentClass;\n        var classDescent = attr.stClassDescent || stConfig.sort.descentClass;\n        var stateClasses = [classAscent, classDescent];\n        var sortDefault;\n        var skipNatural = attr.stSkipNatural !== undefined ? attr.stSkipNatural : stConfig.sort.skipNatural;\n        var descendingFirst = attr.stDescendingFirst !== undefined ? attr.stDescendingFirst : stConfig.sort.descendingFirst;\n        var promise = null;\n        var throttle = attr.stDelay || stConfig.sort.delay;\n        var onSort;\n        if (attr.stOnSort) {\n          onSort = scope.$eval(attr.stOnSort) !== undefined ? scope.$eval(attr.stOnSort) : false;\n        }\n\n        if (attr.stSortDefault) {\n          sortDefault = scope.$eval(attr.stSortDefault) !== undefined ? scope.$eval(attr.stSortDefault) : attr.stSortDefault;\n        }\n\n        //view --> table state\n        function sort () {\n          if (descendingFirst) {\n            index = index === 0 ? 2 : index - 1;\n          } else {\n            index++;\n          }\n\n          var func;\n          predicate = ng.isFunction(getter(scope)) || ng.isArray(getter(scope)) ? getter(scope) : attr.stSort;\n          if (index % 3 === 0 && !!skipNatural !== true) {\n            //manual reset\n            index = 0;\n            ctrl.tableState().sort = {};\n            ctrl.tableState().pagination.start = 0;\n            func = ctrl.pipe.bind(ctrl);\n          } else {\n            func = ctrl.sortBy.bind(ctrl, predicate, index % 2 === 0);\n          }\n          if (promise !== null) {\n            $timeout.cancel(promise);\n          }\n          if (throttle < 0) {\n            func();\n          } else {\n            promise = $timeout(func, throttle);\n          }\n          if (onSort) onSort(predicate, index);\n        }\n\n        element.bind('click', function sortClick () {\n          if (predicate) {\n            scope.$apply(sort);\n          }\n        });\n\n        if (sortDefault) {\n          index = sortDefault === 'reverse' ? 1 : 0;\n          sort();\n        }\n\n        //table state --> view\n        scope.$watch(function () {\n          return ctrl.tableState().sort;\n        }, function (newValue) {\n          if (newValue.predicate !== predicate) {\n            index = 0;\n            element\n              .removeClass(classAscent)\n              .removeClass(classDescent);\n          } else {\n            index = newValue.reverse === true ? 2 : 1;\n            element\n              .removeClass(stateClasses[index % 2])\n              .addClass(stateClasses[index - 1]);\n          }\n        }, true);\n      }\n    };\n  }]);\n\nng.module('smart-table')\n  .directive('stPagination', ['stConfig', function (stConfig) {\n    return {\n      restrict: 'EA',\n      require: '^stTable',\n      scope: {\n        stItemsByPage: '=?',\n        stDisplayedPages: '=?',\n        stPageChange: '&'\n      },\n      templateUrl: function (element, attrs) {\n        if (attrs.stTemplate) {\n          return attrs.stTemplate;\n        }\n        return stConfig.pagination.template;\n      },\n      link: function (scope, element, attrs, ctrl) {\n\n        scope.stItemsByPage = scope.stItemsByPage ? +(scope.stItemsByPage) : stConfig.pagination.itemsByPage;\n        scope.stDisplayedPages = scope.stDisplayedPages ? +(scope.stDisplayedPages) : stConfig.pagination.displayedPages;\n\n        scope.currentPage = 1;\n        scope.pages = [];\n\n        function redraw () {\n          var paginationState = ctrl.tableState().pagination;\n          var start = 1;\n          var end;\n          var i;\n          var prevPage = scope.currentPage;\n          scope.totalItemCount = paginationState.totalItemCount;\n          scope.currentPage = Math.floor(paginationState.start / paginationState.number) + 1;\n\n          start = Math.max(start, scope.currentPage - Math.abs(Math.floor(scope.stDisplayedPages / 2)));\n          end = start + scope.stDisplayedPages;\n\n          if (end > paginationState.numberOfPages) {\n            end = paginationState.numberOfPages + 1;\n            start = Math.max(1, end - scope.stDisplayedPages);\n          }\n\n          scope.pages = [];\n          scope.numPages = paginationState.numberOfPages;\n\n          for (i = start; i < end; i++) {\n            scope.pages.push(i);\n          }\n\n          if (prevPage !== scope.currentPage) {\n            scope.stPageChange({newPage: scope.currentPage});\n          }\n        }\n\n        //table state --> view\n        scope.$watch(function () {\n          return ctrl.tableState().pagination;\n        }, redraw, true);\n\n        //scope --> table state  (--> view)\n        scope.$watch('stItemsByPage', function (newValue, oldValue) {\n          if (newValue !== oldValue) {\n            scope.selectPage(1);\n          }\n        });\n\n        scope.$watch('stDisplayedPages', redraw);\n\n        //view -> table state\n        scope.selectPage = function (page) {\n          if (page > 0 && page <= scope.numPages) {\n            ctrl.slice((page - 1) * scope.stItemsByPage, scope.stItemsByPage);\n          }\n        };\n\n        if (!ctrl.tableState().pagination.number) {\n          ctrl.slice(0, scope.stItemsByPage);\n        }\n      }\n    };\n  }]);\n\nng.module('smart-table')\n  .directive('stPipe', ['stConfig', '$timeout', function (config, $timeout) {\n    return {\n      require: 'stTable',\n      scope: {\n        stPipe: '='\n      },\n      link: {\n\n        pre: function (scope, element, attrs, ctrl) {\n\n          var pipePromise = null;\n\n          if (ng.isFunction(scope.stPipe)) {\n            ctrl.preventPipeOnWatch();\n            ctrl.pipe = function () {\n\n              if (pipePromise !== null) {\n                $timeout.cancel(pipePromise)\n              }\n\n              pipePromise = $timeout(function () {\n                scope.stPipe(ctrl.tableState(), ctrl);\n              }, config.pipe.delay);\n\n              return pipePromise;\n            }\n          }\n        },\n\n        post: function (scope, element, attrs, ctrl) {\n          ctrl.pipe();\n        }\n      }\n    };\n  }]);\n\nng.module('smart-table')\n  .directive('stTreeRow', ['stConfig', function (stConfig) {\n    return {\n      restrict: 'A',\n      require: '^stTable',\n      priority: 1001, // needs to compile before ng-repeat at priority 1000\n      compile: function (tElement, tAttrs) {\n        // add tree attributes\n        var repeat = tAttrs.ngRepeat;\n        var rptVar = repeat.split(' in ')[0];\n        tElement.attr('ng-repeat', repeat + ' track by ' + rptVar + '.$$treeId');\n        tElement.attr('ng-if', rptVar + '.$$treeShown');\n        tElement.attr('ng-class', '\"st-tree-row-\"+' + rptVar + '.treeLevel');\n            \n        var caretEl = angular.element(tElement.find('td')[0]).find('st-tree-caret');\n        caretEl.attr('toggle-exists', rptVar + '.treeLevel > 0');\n        caretEl.attr('toggle-is-expanded', rptVar + '.$$treeIsExpanded');\n        caretEl.attr('toggle-level', rptVar + '.treeLevel');\n        caretEl.attr('st-tree-id', rptVar + '.$$treeId');\n        caretEl.attr('st-tree-level', rptVar + '.treeLevel');\n        caretEl.attr('st-tree-index', '$index');\n      }\n    };\n  }]);\n  \nng.module('smart-table')\n  .directive('stTreeCaret', ['stConfig', function (stConfig) {\n    return {\n      require: '^^stTable',\n      scope: {\n        toggleExists: '<',\n        toggleIsExpanded: '<',\n        toggleLevel: '<',\n        stTreeId: '<',\n        stTreeLevel: '<',\n        stTreeIndex: '<'\n      },\n      templateUrl: 'sttable/template/st-tree-toggle.html',\n      link: function(scope, element, attrs, ctrl) {\n        if (scope.toggleExists) {\n          element.bind('click', function($event) {\n            $event.stopPropagation();\n            ctrl.toggleRow(scope.stTreeId, scope.stTreeIndex);\n          });\n        }\n        scope.spacerClass = 'st-tree-spacer st-tree-spacer-level-' + scope.toggleLevel;\n      }\n    };\n  }]);\n\n})(angular);"],"sourceRoot":"/source/"}